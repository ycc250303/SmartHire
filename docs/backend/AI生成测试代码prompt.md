# step1

你将作为资深 Java Spring 测试架构师，帮助我为系统生成合理数量的单元测试和集成测试。

必须遵守的核心原则：

1. 首要目标是防止回归 bug，而不是追求覆盖率。
2. 禁止根据我现有业务代码结构“迎合”写测试，也禁止 mock 掉所有逻辑导致“假通过”。
3. 控制测试数量，不允许大规模测试用例（我们团队没有测试基础）。
4. 专注业务功能流程，不测试框架行为：
   - 不测试 @Valid 的参数校验
   - 不测试统一鉴权过滤器
   - 不测试 Spring Boot 内置行为
5. 生成的测试必须：易读、易维护、逻辑清晰、适量。

如果理解，请回复：“已理解，请提供 API 文档和 DTO。”

# step2

这是我的 API 文档和 DTO 代码（如下）。

请根据这些信息输出：

1. 建议的测试范围（哪些业务必须测试，哪些可以略过）。
2. 建议的测试优先级（P0 关键业务、P1 次要业务、P2 非必须）。
3. 建议的测试总数量上限（比如总数不超过接口数量*2）
4. 明确指出不需要测试的内容（如参数校验 、鉴权 ）。

禁止：列举超过上限的测试用例。

请输出测试范围方案，不要生成md文件，直接在对话框输出方案。

# step3

根据你刚才给出的测试范围，请为每个 API 生成一个精简的测试用例矩阵，不要生成md文件，直接在对话框中输出。

要求：

- 不超过你建议的用例数量上限。
- 每个接口 1～3 个用例（正常流程 + 1 个典型异常即可）。
- 只测试业务逻辑，不测试框架层行为。
- 每个用例包含：用例编号、测试类型（unit/integration）、前置条件、输入、预期输出、测试理由。
- 强调测试是为了防止回归，而不是为了覆盖所有边界。

不要生成测试代码，只生成表格。

# step4

请你审查刚刚生成的用例矩阵，并执行以下任务：

1. 删除不重要的重复场景。
2. 合并过度相似的测试。
3. 控制总用例数量不超过你之前建议的上限。
4. 确保每个测试都能防止某类回归 bug（请说明原因）。

输出优化后的最终测试用例矩阵。

不要生成代码。

# step5

请根据最终测试用例矩阵，为模块生成 JUnit 单元测试。

要求：

- 每个 Service 一个 Test 文件。
- 使用 Mockito，但不能 mock 掉所有业务（至少要验证真实业务分支）。
- 使用 Arrange / Act / Assert 分段。
- 代码要可读、清晰、适合初级开发者理解。
- 不能根据现有业务代码硬编码，不允许阅读service/impl文件夹中的内容，但是可以阅读service文件夹内非impl文件夹的内容，并根据 API 文档 & 测试矩阵推导行为。

请生成第一个 Service 的单元测试文件。

# step6

请根据最终测试矩阵，为需要集成测试的接口生成集成测试代码。

要求：

- 使用 @SpringBootTest(webEnvironment = RANDOM_PORT)
- 使用 TestRestTemplate 或 WebTestClient
- 使用 H2 内存数据库代替真实 MySQL
- 不使用真实 Redis，可使用 MockBean 或 Embedded Redis
- 覆盖关键业务路径即可，不要写太多

请生成第一个集成测试文件。

# step7

请审查你生成的测试代码是否满足以下标准：

- 是否避免“迎合业务代码”的假通过测试？
- 是否覆盖测试矩阵的关键业务？
- 是否保持逻辑清晰、易读、易维护？
- 是否避免测试框架行为（参数校验、鉴权）？
- 是否真正能防止回归 bug？

请说明测试质量，并列出建议优化点。不要生成md文件，而是直接在对话框输出结果


# 检查

你是一名资深 Java 测试工程师，请根据以下内容判断：

1. 测试失败的根本原因到底是谁：
   - 测试设计错误？
   - 预期值错误？
   - 过度 mock？
   - 业务代码缺陷？
   - 框架行为理解错误？
2. 是否违反了 API 文档 / 业务契约？
3. 是否属于不应由 Service 测试的逻辑？
4. 需要如何修改测试？
5. 需要如何修改业务代码？

下面是提供的信息，请结合分析：

【测试失败日志】
（在此粘贴）

【测试代码】
（在此粘贴）

【相关 API 文档 / 业务规则】
（在此粘贴）

请严格基于接口契约，而不是基于已有业务实现来判断问题来源。
输出最终结论：测试错？还是业务错？以及原因。
不要生成md文件，而是直接在对话框输出结果
